---
title: Async Iterators
difficulty: hard
course: async-javascript
---

# Async Iterators

Implement the `Symbol.asyncIterator` protocol for cursor-based pagination.

## `paginate(fetchPage)`

Turn a cursor-based page fetcher into a lazy `AsyncIterable` that yields individual items. Pages are fetched on demand â€” the next page is not requested until all items from the current page are consumed.

The `fetchPage` function has this signature:

```ts
type Page<T> = { items: T[]; nextCursor?: string };
type FetchPage<T> = (cursor?: string) => Promise<Page<T>>;
```

When `nextCursor` is undefined, there are no more pages.

## `collect(iter)`

Consume an entire `AsyncIterable` into an array.

## `asyncMap(iter, fn)`

Lazily transform each item from an `AsyncIterable` using an async mapping function. Should not eagerly consume the source.

## Hint

An object is async-iterable if it has a `[Symbol.asyncIterator]()` method that returns `{ next(): Promise<{ value, done }> }`.
